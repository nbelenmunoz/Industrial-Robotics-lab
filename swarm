import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.patches import Rectangle, Circle
import numpy as np, math


cell_size    = 30
maze = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,1,0,0,0,1,0,0,1,0,0,1],
    [1,0,1,1,1,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,1,0,1,0,0,0,0,0,1],
    [1,1,1,1,0,1,0,1,1,1,1,1,0,1],
    [1,0,0,1,0,1,0,0,0,1,0,0,0,1],
    [1,0,1,1,0,1,1,1,0,1,0,1,1,1],
    [1,0,0,0,0,0,0,1,0,1,0,0,0,1],
    [1,1,1,1,0,1,0,1,0,1,1,1,0,1],
    [1,0,0,0,0,1,0,0,0,0,0,1,0,1],
    [1,0,1,1,0,1,1,1,1,1,0,1,0,1],
    [1,0,1,1,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,1,1,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,0,1,0,1,0,0,0,1],
    [1,1,1,1,1,1,1,1,0,1,1,1,1,1],
]
maze_h = len(maze)
maze_w = len(maze[0])


num_drones   = 10
step_size    = 6
time_steps   = 2000
start_pos    = np.array((8*cell_size + cell_size/2,
                         14*cell_size + cell_size/2), float)

target_pos    = np.array((6*cell_size + cell_size/2,
                          2*cell_size  + cell_size/2), float)
target_radius = cell_size * 0.8
k_target      = 0.002     # gain toward target

# swarm gains
SENSE_RADIUS = 50
k_conn       = 0.005
desired_d    = SENSE_RADIUS * 0.5
w_noise      = 0.2
w_inertia    = 0.7


def normalize(v):
    norm = np.linalg.norm(v)
    return v / norm if norm>1e-8 else np.zeros_like(v)

def reflect(v, n):
    return normalize(v - 2*np.dot(v,n)*n)

class Drone:
    def __init__(self, idx):
        self.idx      = idx
        self.pos      = start_pos.copy()
        ang           = np.random.uniform(0, 2*math.pi)
        self.hdg      = np.array((math.cos(ang), math.sin(ang)))
        self.state    = 'search'
        self.waypoint = None

    def compute_neighbors(self, drones):
        neigh = []
        for other in drones:
            if other is self: continue
            d = other.pos - self.pos
            dist = np.linalg.norm(d)
            if dist <= SENSE_RADIUS and dist>1e-6:
                neigh.append((other, d, dist))
        return neigh

    def check_collision(self, new_pos):
        gx = int(new_pos[0] // cell_size)
        gy = int(new_pos[1] // cell_size)
        if (0 <= gx < maze_w and 0 <= gy < maze_h and maze[gy][gx]==0):
            return False, None
        old_cell = (int(self.pos[0]//cell_size), int(self.pos[1]//cell_size))
        dx_cell = gx - old_cell[0]
        dy_cell = gy - old_cell[1]
        normal = np.array([0.0,0.0])
        if dx_cell!=0: normal[0] = -math.copysign(1, dx_cell)
        if dy_cell!=0: normal[1] = -math.copysign(1, dy_cell)
        normal = normalize(normal)
        return True, normal



    def update(self, drones):
        if self.state == 'chain':
            dvec = self.waypoint - self.pos
            new_hdg = normalize(dvec)
            new_pos = self.pos + new_hdg * step_size
            collision, normal = self.check_collision(new_pos)
            if collision:
                new_hdg = reflect(new_hdg, normal)
            else:
                self.pos = new_pos
            self.hdg = new_hdg
            return

        # target attraction
        to_goal = target_pos - self.pos
        dist_goal = np.linalg.norm(to_goal)
        if dist_goal < target_radius:
            # first finder initializes the chain
            global chain_waypoints
            if chain_waypoints is None:
                # build waypoints from target back to start
                delta = (target_pos - start_pos) / (num_drones-1)
                chain_waypoints = [
                    target_pos - i*delta
                    for i in range(num_drones)
                ]
                # assign each drone its waypoint
                for d in drones:
                    d.state    = 'chain'
                    d.waypoint = chain_waypoints[d.idx]
            return


        force = np.zeros(2)
        for _, dvec, dist in self.compute_neighbors(drones):
            force += k_conn * (dist - desired_d) * (dvec/dist)

        
        force += w_noise * normalize(np.random.uniform(-1,1,2))

        
        force += w_inertia * self.hdg
        force += k_target * to_goal

        
        new_hdg  = normalize(force)
        new_pos  = self.pos + new_hdg * step_size
        coll, n = self.check_collision(new_pos)
        if coll:
            new_hdg = reflect(new_hdg, n)
        else:
            self.pos = new_pos
        self.hdg = new_hdg

chain_waypoints = None
fig, ax = plt.subplots(figsize=(7,7))
drones = [Drone(i) for i in range(num_drones)]

def draw():
    ax.clear(); ax.set_aspect('equal')
    ax.set_xticks([]); ax.set_yticks([])

    for y in range(maze_h):
      for x in range(maze_w):
        if maze[y][x]==1:
          ax.add_patch(Rectangle((x*cell_size, y*cell_size),
                                 cell_size, cell_size,
                                 color='black'))

    ax.add_patch(Circle(target_pos, target_radius,
                        color='red', alpha=0.3))

    for d in drones:
      style = 'tab:green' if d.state=='chain' else 'tab:orange'
      ax.add_patch(Circle(d.pos, SENSE_RADIUS,
                          fill=False, linestyle='--', alpha=0.1))
      ax.plot(d.pos[0], d.pos[1], 'o',
              color=style, markersize=6)

    ax.set_xlim(0, maze_w*cell_size)
    ax.set_ylim(0, maze_h*cell_size)
    ax.invert_yaxis()

def update(frame):
    for d in drones:
        d.update(drones)
    draw()

ani = animation.FuncAnimation(fig, update,
                              frames=time_steps,
                              interval=20)
plt.show()